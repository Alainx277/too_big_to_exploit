use std::sync::Arc;

use axum::{extract::State, response::Redirect, Form};
use base64::Engine;
use rand::RngCore;
use serde::Deserialize;
use tokio_postgres::Client;
use tower_cookies::{Cookie, Cookies};

use crate::session::delete_session;

pub async fn do_login(
    State(db): State<Arc<Client>>,
    cookies: Cookies,
    Form(login): Form<LoginParams>,
) -> Redirect {
    // Security problem: plain-text password in database
    let rows = db
        .query(
            "SELECT id FROM users WHERE username = $1 AND password = $2 LIMIT 1",
            &[&login.username, &login.password],
        )
        .await
        .unwrap();
    if rows.is_empty() {
        return Redirect::to("/?error=credentials");
    }
    let user_id: i32 = rows.first().unwrap().get(0);

    // Generate a session token (128 bits)
    // using a cryptographically secure generator
    let mut token_bytes = [0u8; 16];
    {
        let mut rng = rand::thread_rng();
        rng.fill_bytes(&mut token_bytes);
    }
    let token = base64::prelude::BASE64_STANDARD.encode(token_bytes);

    // Save to database
    db.execute(
        "INSERT INTO sessions (token, user_id) VALUES ($1, $2)",
        &[&token, &user_id],
    )
    .await
    .unwrap();

    // Set the session token as a cookie
    cookies.add(Cookie::new("session", token.clone()));

    Redirect::to("/dashboard")
}

pub async fn do_logout(State(db): State<Arc<Client>>, cookies: Cookies) -> Redirect {
    delete_session(db.as_ref(), &cookies).await;
    Redirect::to("/")
}

#[derive(Deserialize)]
pub struct LoginParams {
    username: String,
    password: String,
}
