use std::sync::Arc;

use argon2::{Argon2, PasswordHash, PasswordVerifier};
use axum::{extract::State, response::Redirect, Form};
use base64::Engine;
use rand::RngCore;
use serde::Deserialize;
use tower_cookies::{cookie::SameSite, Cookie, Cookies};
use tracing::{info, warn};

use crate::{session::delete_session, AppState};

pub async fn do_login(
    State(state): State<Arc<AppState>>,
    cookies: Cookies,
    Form(login): Form<LoginParams>,
) -> Redirect {
    let db = &state.client;

    let row = db
        .query_opt(
            "SELECT id, password_hash FROM users WHERE username = $1 LIMIT 1",
            &[&login.username],
        )
        .await
        .unwrap();
    let Some(row) = row else {
        warn!(user = login.username, "Authentication failed");
        return Redirect::to("/?error=credentials");
    };
    let user_id: i32 = row.get(0);
    let password_hash: String = row.get(1);

    // Verify password against hash
    let parsed_hash = PasswordHash::new(&password_hash).unwrap();
    if Argon2::default()
        .verify_password(login.password.as_bytes(), &parsed_hash)
        .is_err()
    {
        warn!(user = login.username, "Authentication failed");
        return Redirect::to("/?error=credentials");
    }

    // Generate a session token (128 bits)
    // using a cryptographically secure generator
    let mut token_bytes = [0u8; 16];
    {
        let mut rng = rand::thread_rng();
        rng.fill_bytes(&mut token_bytes);
    }
    let token = base64::prelude::BASE64_STANDARD.encode(token_bytes);

    // Save to database
    db.execute(
        "INSERT INTO sessions (token, user_id) VALUES ($1, $2)",
        &[&token, &user_id],
    )
    .await
    .unwrap();

    // Set the session token as a cookie
    let mut cookie = Cookie::new("session", token.clone());
    cookie.set_same_site(SameSite::Lax);
    cookies.add(cookie);

    info!(user = login.username, "User authenticated");

    Redirect::to("/dashboard")
}

pub async fn do_logout(State(state): State<Arc<AppState>>, cookies: Cookies) -> Redirect {
    delete_session(&state.client, &cookies).await;
    Redirect::to("/")
}

#[derive(Deserialize)]
pub struct LoginParams {
    username: String,
    password: String,
}
